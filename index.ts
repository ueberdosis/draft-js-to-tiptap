import type {
  RawDraftContentState,
  RawDraftContentBlock,
  RawDraftInlineStyleRange,
  RawDraftEntityRange,
  RawDraftEntity,
} from "draft-js";
import {
  type MarkType,
  type NodeType,
  addChild,
  type TextType,
  addMark,
  createNode,
  createText,
  createDocument,
  isListNode,
  type NodeMapping,
} from "./Node";

/**
 * A function that maps a Draft.js block to a ProseMirror node.
 */
type MapBlockToNodeFn = (
  this: DraftConverter,
  context: {
    /**
     * The Draft.js block to render.
     */
    block: RawDraftContentBlock;
    /**
     * The entity map of the Draft.js content.
     */
    entityMap: RawDraftContentState["entityMap"];
    /**
     * The previous Node generated by the renderer.
     */
    previousNode: NodeType | null;
    /**
     * The previous block run through the renderer.
     */
    previousBlock: RawDraftContentBlock | null;
    /**
     * A function that renders the default content of a block.
     * Returning `null` when the block is not matched to any of the defaults.
     */
    defaultRenderer: (
      context: Omit<Parameters<MapBlockToNodeFn>[0], "defaultRenderer">
    ) => NodeType | null;
  }
) => NodeType | null;

type MapInlineStyleToMarkFn = (
  this: DraftConverter,
  inlineStyleRange: RawDraftInlineStyleRange
) => MarkType | null;

type MapEntityToMarkFn = (
  this: DraftConverter,
  range: RawDraftEntityRange,
  entityMap: RawDraftContentState["entityMap"]
) => MarkType | null;

type MapEntityToNodeFn = (
  this: DraftConverter,
  range: RawDraftEntityRange,
  entityMap: RawDraftContentState["entityMap"]
) => NodeType | null;

type DraftConverterOptions = {
  mapBlockToNode: MapBlockToNodeFn;
  mapInlineStyleToMark: MapInlineStyleToMarkFn;
  mapEntityToMark: MapEntityToMarkFn;
  mapEntityToNode: MapEntityToNodeFn;
};

export const inlineStyleToMark: Record<string, MarkType> = {
  BOLD: { type: "bold" },
  CODE: { type: "code" },
  KEYBOARD: { type: "code" },
  ITALIC: { type: "italic" },
  STRIKETHROUGH: { type: "strike" },
  UNDERLINE: { type: "underline" },
  SUBSCRIPT: { type: "subscript" },
  SUPERSCRIPT: { type: "superscript" },
};

export const entityToMark: Record<
  string,
  (entity: RawDraftEntity) => MarkType | null
> = {
  LINK: (entity) => {
    return {
      type: "link",
      attrs: {
        href: entity.data.url,
        target: entity.data.target,
      },
    };
  },
};

export const entityToNode: Record<
  string,
  (entity: RawDraftEntity) => NodeType | null
> = {
  IMAGE: (entity) => {
    return {
      type: "image",
      attrs: {
        src: entity.data.src,
        alt: entity.data.alt,
      },
    };
  },
};

export class DraftConverter {
  public unmatchedBlocks: RawDraftContentBlock[] = [];
  public unmatchedEntities: RawDraftEntity[] = [];
  public unmatchedInlineStyles: RawDraftInlineStyleRange[] = [];
  private options: DraftConverterOptions;

  constructor(options: Partial<DraftConverterOptions>) {
    this.options = {
      mapBlockToNode: function ({ defaultRenderer, ...ctx }) {
        return defaultRenderer(ctx);
      },
      mapInlineStyleToMark: this.defaultInlineStyleToMark,
      mapEntityToMark: this.defaultEntityToMark,
      mapEntityToNode: this.defaultEntityToNode,
      ...options,
    };
  }

  defaultInlineStyleToMark({ style }: { style: string }): MarkType | null {
    if (inlineStyleToMark[style]) {
      return inlineStyleToMark[style];
    }

    if (style.startsWith("bgcolor-")) {
      return {
        type: "highlight",
        attrs: {
          color: style.replace("bgcolor-", ""),
        },
      };
    }
    if (style.startsWith("fontfamily-")) {
      return {
        type: "textStyle",
        attrs: {
          fontFamily: style.replace("fontfamily-", ""),
        },
      };
    }
    return null;
  }

  defaultEntityToNode(
    { key }: RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ): NodeType | null {
    if (entityToNode[entityMap[key].type]) {
      return entityToNode[entityMap[key].type](entityMap[key]);
    }

    return null;
  }

  defaultEntityToMark(
    { key }: RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ): MarkType | null {
    if (entityToMark[entityMap[key].type]) {
      return entityToMark[entityMap[key].type](entityMap[key]);
    }

    return null;
  }

  mapRangeToMark(
    range: RawDraftInlineStyleRange | RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ): MarkType | null {
    if ("style" in range) {
      const inlineStyle = (
        this.options.mapInlineStyleToMark || this.defaultInlineStyleToMark
      ).bind(this)(range);

      if (inlineStyle) {
        return inlineStyle;
      }

      this.unmatchedInlineStyles.push(range);
      return null;
    }

    const entity = (
      this.options.mapEntityToMark || this.defaultEntityToMark
    ).bind(this)(range, entityMap);

    if (entity) {
      return entity;
    }

    this.unmatchedEntities.push(entityMap[range.key]);
    return null;
  }

  /**
   * This function splits a text into Nodes based on the entity ranges and inline style ranges.
   * Applying them as marks to the text. Which may overlap in their ranges.
   */
  splitTextByEntityRangesAndInlineStyleRanges(options: {
    /**
     * The Draft.js block to render.
     */
    block: RawDraftContentBlock;
    /**
     * The entity map of the Draft.js content.
     */
    entityMap: RawDraftContentState["entityMap"];
  }): TextType[] {
    const allRanges = [
      ...options.block.entityRanges,
      ...options.block.inlineStyleRanges,
    ].sort((a, b) => {
      // sort by range, then by length
      if (a.offset === b.offset) {
        return a.length - b.length;
      }
      return a.offset - b.offset;
    });

    let result: {
      text: string;
      ranges: (RawDraftEntityRange | RawDraftInlineStyleRange)[];
    }[] = [];
    let stylesAtPosition: {
      [key: number]: (RawDraftEntityRange | RawDraftInlineStyleRange)[];
    } = {};

    // Create a map of styles at each position
    for (let range of allRanges) {
      for (let i = range.offset; i < range.offset + range.length; i++) {
        if (!stylesAtPosition[i]) {
          stylesAtPosition[i] = [];
        }
        stylesAtPosition[i].push(range);
      }
    }

    // Split the text into groups by their range
    let currentRanges: (RawDraftEntityRange | RawDraftInlineStyleRange)[] = [];
    let currentText: string = "";
    for (let i = 0; i < options.block.text.length; i++) {
      let styles = stylesAtPosition[i] || [];
      if (
        styles.length !== currentRanges.length ||
        !styles.every((style) => currentRanges.includes(style))
      ) {
        if (currentText) {
          result.push({ text: currentText, ranges: currentRanges });
        }
        currentText = "";
        currentRanges = styles;
      }
      currentText += options.block.text[i];
    }

    if (currentText) {
      result.push({ text: currentText, ranges: currentRanges });
    }

    return result.map(({ text, ranges }) => {
      const textNode: TextType = { type: "text", text, marks: [] };

      ranges.forEach((range) =>
        addMark(textNode, this.mapRangeToMark(range, options.entityMap))
      );

      return textNode;
    });
  }

  mapBlockToNode: Parameters<MapBlockToNodeFn>["0"]["defaultRenderer"] = ({
    block,
    entityMap,
    previousBlock,
    previousNode,
  }) => {
    switch (block.type) {
      case "atomic": {
        if (block.entityRanges.length === 0) {
          if (block.inlineStyleRanges.length === 0) {
            // Plain text, fast path
            return createText(block.text);
          }
        }
        // TODO atomic blocks use entities, to generate nodes
        // Does it make sense to wrap them in a paragraph?
        const paragraph = createNode("paragraph");
        const entities = block.entityRanges
          .map((range) =>
            (this.options.mapEntityToNode || this.defaultEntityToNode).bind(
              this
            )(range, entityMap)
          )
          .filter(Boolean);
        if (entities.length === 0) {
          return null;
        }
        entities.forEach((node) => {
          addChild(paragraph, node);
        });

        return paragraph;
      }
      case "unstyled": {
        const paragraph = createNode("paragraph");
        if (block.inlineStyleRanges.length === 0) {
          if (block.entityRanges.length === 0) {
            // Plain text, fast path
            return addChild(paragraph, createText(block.text));
          }
        }

        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((node) => {
          addChild(paragraph, node);
        });

        return paragraph;
      }
      case "blockquote": {
        const blockquote = createNode("blockquote");
        const paragraph = createNode("paragraph");

        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((node) => {
          addChild(paragraph, node);
        });

        return addChild(blockquote, paragraph);
      }
      case "code-block": {
        const codeBlock = createNode("codeBlock");
        const text = createText(block.text);
        addChild(codeBlock, text);

        return codeBlock;
      }
      case "header-one":
      case "header-two":
      case "header-three":
      case "header-four":
      case "header-five":
      case "header-six": {
        const headingLevel = {
          "header-one": 1,
          "header-two": 2,
          "header-three": 3,
          "header-four": 4,
          "header-five": 5,
          "header-six": 6,
        }[block.type];
        const heading = createNode("heading", {
          attrs: { level: headingLevel },
        });

        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((node) => {
          addChild(heading, node);
        });

        return heading;
      }
      /**
       * Lists are represented as a tree structure in ProseMirror.
       * Whereas in Draft.js they are represented as a flat list.
       * So, we need to build the tree structure for the list.
       */
      case "unordered-list-item":
      case "ordered-list-item": {
        // First, we create the list item
        const listItem = createNode("listItem");
        const paragraph = createNode("paragraph");

        // And add the paragraph to the list item
        addChild(listItem, paragraph);

        // Then, we add the text to it's paragraph
        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((node) => {
          addChild(paragraph, node);
        });

        const startListNode =
          isListNode(previousNode) && previousBlock?.type === block.type
            ? previousNode
            : block.type === "unordered-list-item"
            ? createNode("bulletList")
            : createNode("orderedList");

        let listNode = startListNode;

        let depth = 0;
        while (depth < block.depth) {
          if (!listNode.content?.length) {
            listNode.content = [];
          }
          // There are list items in-between, find the most recent one
          let mostRecentListItem =
            listNode.content[listNode.content.length - 1];
          if (!mostRecentListItem) {
            mostRecentListItem = createNode("listItem");
            addChild(listNode, mostRecentListItem);
          }

          let nextMostRecentList =
            mostRecentListItem.content?.[mostRecentListItem.content.length - 1];

          if (isListNode(nextMostRecentList)) {
            // We found a list, move to the next one
            listNode = nextMostRecentList;

            depth++;
          } else {
            // We didn't find a list, in the last position, create a new one
            nextMostRecentList =
              block.type === "unordered-list-item"
                ? createNode("bulletList")
                : createNode("orderedList");

            addChild(mostRecentListItem, nextMostRecentList);

            listNode = nextMostRecentList;
            // Tiptap doesn't support nesting lists, so we break here
            break;
          }
        }

        // We found the correct list, add the list item
        addChild(listNode, listItem);

        // Return the whole list structure (whether it was created or not)
        return startListNode;
      }
    }
    // Default renderer for Draft.js blocks
    return null;
  };

  convertFromDraft(draft: RawDraftContentState) {
    const doc = createDocument();

    let previousNode: NodeType | null = null;
    let previousBlock: RawDraftContentBlock | null = null;

    draft.blocks.forEach((block) => {
      const nextNode = this.options.mapBlockToNode.call(this, {
        block,
        entityMap: draft.entityMap,
        defaultRenderer: this.mapBlockToNode.bind(this),
        previousNode,
        previousBlock,
      });

      if (nextNode) {
        // Skip adding the Node if it's the same as the previous one (e.g. a list item)
        if (nextNode !== previousNode) {
          addChild(doc, nextNode);
        }

        previousNode = nextNode;
      } else {
        this.unmatchedBlocks.push(block);
      }
      previousBlock = block;
    });

    return doc;
  }
}
