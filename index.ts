import draft from "./draft-input.json";
// import type { Node, Schema } from "prosemirror-model";
import type {
  RawDraftContentState,
  RawDraftContentBlock,
  RawDraftInlineStyleRange,
  RawDraftEntityRange,
} from "draft-js";
import type { MarkType, DocumentType, DefaultContext } from "./Node";
import { Document, Node, Text, Mark } from "./Node";

/**
 * A function that maps a Draft.js block to a ProseMirror node.
 */
type DraftRenderer<T extends DefaultContext> = (
  this: DraftConverter<T>,
  context: {
    /**
     * The Draft.js block to render.
     */
    block: RawDraftContentBlock;
    /**
     * The entity map of the Draft.js content.
     */
    entityMap: RawDraftContentState["entityMap"];
    /**
     * The previous Node generated by the renderer.
     */
    previousNode: Node | null;
    /**
     * The previous block run through the renderer.
     */
    previousBlock: RawDraftContentBlock | null;
    /**
     * A function that renders the default content of a block.
     * Returning `null` when the block is not matched to any of the defaults.
     */
    defaultRenderer: (
      context: Omit<Parameters<DraftRenderer<T>>[0], "defaultRenderer">
    ) => Node | null;
    /**
     * Mutable context maintained by the renderer, as it parses.
     */
    context: T;
  }
) => Node | null;

type DraftConverterOptions<T extends DefaultContext> = {
  renderDraftBlock: DraftRenderer<T>;
  mapInlineStyleToMark?: (context: RawDraftInlineStyleRange) => MarkType | null;
  mapEntityToMark?: (
    context: RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ) => MarkType | null;
};

class DraftConverter<T extends DefaultContext> {
  private options: DraftConverterOptions<T>;

  constructor(options: DraftConverterOptions<T>) {
    this.options = options;
  }

  /**
   * Creates an Node.
   */
  static createNode(options: ConstructorParameters<typeof Node>["0"]): Node {
    return new Node(options);
  }

  /**
   * Creates a doc Node.
   */
  static createDocument(): Document {
    return new Document();
  }

  /**
   * Creates a text Node.
   */
  static createTextNode(text: string, marks?: Mark[] | MarkType[]): Node {
    return new Text({
      text,
      marks,
    });
  }

  static createParagraphNode(
    options?: Omit<ConstructorParameters<typeof Node>["0"], "type">
  ): Node {
    return DraftConverter.createNode({
      type: "paragraph",
      ...options,
    });
  }

  defaultInlineStyleToMark({ style }: { style: string }): MarkType | null {
    // Default mapping of Draft.js inline styles to marks
    switch (style) {
      case "BOLD": {
        return {
          type: "strong",
        };
      }
      case "CODE": {
        return {
          type: "code",
        };
      }
      case "ITALIC": {
        return {
          type: "italic",
        };
      }
      case "STRIKETHROUGH": {
        return {
          type: "strike",
        };
      }
      case "UNDERLINE": {
        return {
          type: "underline",
        };
      }
      case "SUBSCRIPT": {
        return {
          type: "subscript",
        };
      }
      case "SUPERSCRIPT": {
        return {
          type: "superscript",
        };
      }
    }

    // Mapping of react-draft-wysiwyg inline styles to marks
    if (style.startsWith("color-")) {
      return {
        type: "color",
        attrs: {
          color: style.replace("color-", ""),
        },
      };
    }
    if (style.startsWith("bgcolor-")) {
      return {
        type: "highlight",
        attrs: {
          color: style.replace("bgcolor-", ""),
        },
      };
    }
    // if (style.startsWith("fontsize-")) {
    //   return {
    //     type: "textStyle",
    //     attrs: {
    //       size: style.replace("fontsize-", ""),
    //     },
    //   };
    // }
    if (style.startsWith("fontfamily-")) {
      return {
        type: "textStyle",
        attrs: {
          fontFamily: style.replace("fontfamily-", ""),
        },
      };
    }
    return null;
  }

  defaultEntityToMark(
    { key }: RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ): MarkType | null {
    return {
      type: entityMap[key].type.toLocaleLowerCase(),
      attrs: entityMap[key].data,
    };
  }

  mapRangeToMark(
    range: RawDraftInlineStyleRange | RawDraftEntityRange,
    entityMap: RawDraftContentState["entityMap"]
  ): MarkType | null {
    if ("style" in range) {
      return (
        this.options.mapInlineStyleToMark || this.defaultInlineStyleToMark
      )(range);
    }
    return (this.options.mapEntityToMark || this.defaultEntityToMark)(
      range,
      entityMap
    );
  }

  /**
   * This function splits a text into Nodes based on the entity ranges and inline style ranges.
   * Applying them as marks to the text. Which may overlap in their ranges.
   */
  splitTextByEntityRangesAndInlineStyleRanges(options: {
    /**
     * The Draft.js block to render.
     */
    block: RawDraftContentBlock;
    /**
     * The entity map of the Draft.js content.
     */
    entityMap: RawDraftContentState["entityMap"];
  }): Node[] {
    const allRanges = [
      ...options.block.entityRanges,
      ...options.block.inlineStyleRanges,
    ].sort((a, b) => {
      // sort by range, then by length
      if (a.offset === b.offset) {
        return a.length - b.length;
      }
      return a.offset - b.offset;
    });

    let result: {
      text: string;
      ranges: (RawDraftEntityRange | RawDraftInlineStyleRange)[];
    }[] = [];
    let stylesAtPosition: {
      [key: number]: (RawDraftEntityRange | RawDraftInlineStyleRange)[];
    } = {};

    // Create a map of styles at each position
    for (let range of allRanges) {
      for (let i = range.offset; i < range.offset + range.length; i++) {
        if (!stylesAtPosition[i]) {
          stylesAtPosition[i] = [];
        }
        stylesAtPosition[i].push(range);
      }
    }

    // Split the text into groups by their range
    let currentRanges: (RawDraftEntityRange | RawDraftInlineStyleRange)[] = [];
    let currentText: string = "";
    for (let i = 0; i < options.block.text.length; i++) {
      let styles = stylesAtPosition[i] || [];
      if (
        styles.length !== currentRanges.length ||
        !styles.every((style) => currentRanges.includes(style))
      ) {
        if (currentText) {
          result.push({ text: currentText, ranges: currentRanges });
        }
        currentText = "";
        currentRanges = styles;
      }
      currentText += options.block.text[i];
    }

    if (currentText) {
      result.push({ text: currentText, ranges: currentRanges });
    }

    return result.map(({ text, ranges }) => {
      const Node = DraftConverter.createTextNode(text);
      ranges.forEach((range) =>
        Node.addMark(this.mapRangeToMark(range, options.entityMap))
      );
      return Node;
    });
  }

  defaultDraftRenderer: Parameters<
    DraftRenderer<DefaultContext>
  >["0"]["defaultRenderer"] = ({
    block,
    entityMap,
    context,
    previousBlock,
    previousNode,
  }) => {
    switch (block.type) {
      case "unstyled": {
        const paragraph = DraftConverter.createParagraphNode();
        if (block.inlineStyleRanges.length === 0) {
          if (block.entityRanges.length === 0) {
            // Plain text, fast path
            return paragraph.addNode(DraftConverter.createTextNode(block.text));
          }
        }

        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((Node) => {
          paragraph.addNode(Node);
        });

        return paragraph;
      }
      case "unordered-list-item":
      case "ordered-list-item": {
        const listItem = DraftConverter.createNode({
          type: "listItem",
        });

        this.splitTextByEntityRangesAndInlineStyleRanges({
          block,
          entityMap,
        }).forEach((Node) => {
          listItem.addNode(Node);
        });

        if (
          previousNode &&
          (previousNode.type === "bulletList" ||
            previousNode.type === "orderedList")
        ) {
          // Already in a list, add the list item to the previous list
          return previousNode.addNode(listItem);
        }

        // Not in a list, create a new list
        const list = DraftConverter.createNode({
          type:
            block.type === "unordered-list-item" ? "bulletList" : "orderedList",
        });

        return list.addNode(listItem);
      }
    }
    // Default renderer for Draft.js blocks
    return null;
  };

  convertFromDraft(draft: RawDraftContentState): DocumentType {
    const doc = DraftConverter.createDocument();

    let context: T = {} as T;
    let previousNode: Node | null = null;
    let previousBlock: RawDraftContentBlock | null = null;

    draft.blocks.forEach((block) => {
      const nextNode = this.options.renderDraftBlock.call(this, {
        block,
        entityMap: draft.entityMap,
        defaultRenderer: this.defaultDraftRenderer.bind(this),
        previousNode,
        previousBlock,
        context,
      }) as Node | null;

      if (nextNode && nextNode !== previousNode) {
        // Skip adding the Node if it's the same as the previous one (e.g. a list item)
        doc.addNode(nextNode);
        previousNode = nextNode;
      }
      previousBlock = block;
    });

    return doc.toJSON() as DocumentType;
  }
}

const converter = new DraftConverter({
  renderDraftBlock: function ({ defaultRenderer, ...ctx }) {
    return defaultRenderer(ctx);
  },
});

const output = converter.convertFromDraft(draft as any);

console.log(JSON.stringify(output, null, 2));
